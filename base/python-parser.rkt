#lang racket

(require racket/match
	 "python-lexer.rkt"
	 "python-grammar.rkt")

(provide parse-python)

#| 

The AST expected by get-structured-python is a has of symbol -> (string | number | AST), as produced by Python's AST library and imported in parse-python.rkt. The main non-obvious aspect of it is the 'ctx attribute of each expression node, which is (probably) determined by the statement and expression productions. 

The AST generated by ragg is syntax-object, which is basically a map of the entire derivation of the program.

Example:
(syntax->datum (parse '(NAME NEWLINE)))
'(file_input
  (stmt
   (simple_stmt
    (small_stmt
     (expr_stmt
      (testlist (test (or_test (and_test (not_test (comparison (expr (xor_expr (and_expr (shift_expr (arith_expr (term (factor (power (atom NAME)))))))))))))))))
    NEWLINE)))

|#

;; Unless noted, unmatched cases are unhandled and matched cases are thought to be correct.
;; Some cases are very specific to covered set of python reference tests at the moment.

(define (parse-python port)
  (py-ragg->python-ast (syntax->datum (parse (get-python-lexer port)))))

(define ast hasheq)

(define (args arg-list)
  (ast 'args arg-list
       'defaults '()
       'nodetype "arguments"
       'vararg #\nul
       'kwargannotation #\nul
       'kwarg #\nul
       'varargannotation #\nul
       'kw_defaults '()
       'kwonlyargs '()))

;; Takes two strings. If they are the same, return ast as if it is a one-word op.
;; Only changes the result for "is not".
(define (comp-op->python-ast comp-op)
  (ast 'nodetype
       (match (cdr comp-op)
	 [`("<") "Lt"]
	 [`(">") "Gt"]
	 [`("==") "Eq"]
	 [`(">=") "GtE"]
	 [`("<=") "LtE"]
	 [`("!=") "NotEq"]
	 [`("in") "In"]
	 [`("not" "in") "NotIn"]
	 [`("<>") (error "<> operator is not supported.")]
	 [`("is") "Is"]
	 [`("is" "not") "IsNot"])))

(define (suite->ast-list suite)
  (match suite
    [(list 'suite stmt) 
     (list (py-ragg->python-ast stmt))]
    [(list 'suite "NEWLINE" "INDENT" stmts ... "DEDENT")
     (map py-ragg->python-ast stmts)]))

;; trailer: line to list of args 
;; Currently positional args only
(define (trailer->ast-list trailer)
  (local ((define (more-args arg-lst acc)
	    (match arg-lst
	      [(list) (reverse acc)]
	      [(list arg) (reverse (cons (expr->python-ast arg "Load") acc))]
	      [(list arg "," rest ...) (more-args rest (cons (expr->python-ast arg "Load") acc))])))
	 (match trailer
	   [(list 'trailer "(" ")") '()]
	   [(list 'trailer "(" (list 'arglist rest ...) ")") (more-args rest '())]
	   [_ (error "Unsupported trailer (arglist) shape")])))
	       

;; Transform most of the non-expression grammar from ragg into the ast (hasheq symbol->various) format
(define (py-ragg->python-ast py-ragg)
  (match py-ragg
    [(list 'file_input stmts ...)
     (ast 'nodetype "Module"
	   'body (map py-ragg->python-ast stmts))]
    
    [(list (or 'stmt 'flow_stmt 'small_stmt 'compound_stmt) stmt) 
     (py-ragg->python-ast stmt)]

    [(list 'simple_stmt stmt NEWLINE) (py-ragg->python-ast stmt)] ; Todo: simple-stmt-multi.py
    
    ; TODO: Allow only assignments to those allowed by http://docs.python.org/3.2/reference/simple_stmts.html#assignment-statements
    ;; expr_stmt TODO: multiple targets, multiple values? (in expr->python-ast ?)
    [(list 'expr_stmt testlist "=" val)
     (ast 'nodetype "Assign"
	   'targets (list (expr->python-ast testlist "Store"))
	   'value (expr->python-ast val "Load"))]

    [(list 'expr_stmt testlist (list 'augassign op) val)
     (ast 'nodetype "AugAssign"
	  'op (ast 'nodetype (case op 
			       [("+=") "Add"]
			       [("-=") "Sub"]
			       [("*=") "Mult"]
			       [("/=") "Div"]
			       [("%=") "Mod"]
			       [("&=") "BitAnd"]
			       [("|=") "BitOr"]
			       [("^=") "BitXor"]
			       [(">>=") "RShift"]
			       [("**=") "Pow"]
			       [("//=") "FloorDiv"]
			       [else (error "Unrecognized augassign op")]))
	  'target (expr->python-ast testlist "Store")
	  'value (expr->python-ast val "Load"))]

    [(list 'expr_stmt val)
     (ast 'nodetype "Expr"
	  'value (expr->python-ast val "Load"))]

    [(list 'return_stmt "return" val)
     (ast 'nodetype "Return"
	  'value (expr->python-ast val "Load"))]

    ;; raise_stmt TODO: from clause
    [(list 'raise_stmt "raise" exc)
     (ast 'nodetype "Raise"
	  'exc (expr->python-ast exc "Load")
	  'cause #\nul)]

    [(list 'pass_stmt "pass")
     (ast 'nodetype "Pass")]
    
    ;; assert_stmt TODO: msg
    [(list 'assert_stmt "assert" expr)
     (ast 'nodetype "Assert"
	  'test (expr->python-ast expr "Load")
	  'msg #\nul)]

    ;; global_stmt TODO: multiple names
    [(list 'global_stmt "global" (cons 'name name))
     (ast 'nodetype "Global"
	  'names (list name))]

    ;; if_stmt TODO: multiple elif and opt. else
    [(list 'if_stmt "if" test ":" suite)
     (ast 'nodetype "If"
	  'orelse '()
	  'test (expr->python-ast test "Load")
	  'body (suite->ast-list suite))]
    
    [(list 'if_stmt "if" test ":" suite1 "else" ":" suite2)
     (ast 'nodetype "If"
	  'test (expr->python-ast test "Load")
	  'body (suite->ast-list suite1)
	  'orelse (suite->ast-list suite2))]
    
    ;; try_stmt TODO: All, this is a very special case
    [(list 'try_stmt "try" ":" try-suite 
	   (list 'except_clause "except" except-expr) ":" except-suite
	   "else" ":" else-suite)
     (ast 'nodetype "TryExcept"
	  'body (suite->ast-list try-suite)
	  'orelse (suite->ast-list else-suite)
	  'handlers (list (ast 'nodetype "ExceptHandler"
			       'name #\nul
			       'body (suite->ast-list except-suite)
			       'type (expr->python-ast except-expr "Load"))))]
     
    ;; funcdef TODO: Almost everything
    [`(funcdef "def" (name . ,name) (parameters "(" ")") ":" ,suite)
     (ast 'nodetype "FunctionDef"
	  'body (suite->ast-list suite)
	  'args (args '())
	  'name name
	  'returns #\nul
	  'decorator_list '())]

    ;; classdef TODO: Almost everything
    [`(classdef "class" (name . ,name) ":" ,suite)
     (ast 'nodetype "ClassDef"
	  'body (suite->ast-list suite)
	  'bases '()
	  'name name
	  'decorator_list '()
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '())]

    [_ 
     (display "=== Unhandled grammar ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled grammar"))]))

;; Destructure ragg python expressions to python-ast with ctx value appropriate to the statement, expression, and position.
;; I believe the expr-ctx passed on will inherently be "Load" in almost all cases, 
;; but I'm passing expr-ctx forward until I'm sure
(define (expr->python-ast py-ragg expr-ctx)
  (match py-ragg

    #| Expression fallthroughs... |#
    [(list (or 'argument 'testlist_comp 'testlist 'test 'or_test 'and_test 'not_test 'comparison 'expr 'xor_expr 'and_expr 'shift_expr 'arith_expr 'term 'factor 'power) expr)
     (expr->python-ast expr expr-ctx)]
    
    [(list 'comparison (and (not (cons 'comparison _)) expr1) comp-op (and (not (cons 'comparison _)) expr2))
     (ast 'nodetype "Compare"
	  'left (expr->python-ast expr1 expr-ctx)
	  'ops (list (comp-op->python-ast comp-op))
	  'comparators (list (expr->python-ast expr2 expr-ctx)))]

    [(list (or 'arith_expr 'term) expr1 op expr2)
     (ast 'nodetype "BinOp"
	  'left (expr->python-ast expr1 expr-ctx)
	  'right (expr->python-ast expr2 expr-ctx)
	  'op (ast 'nodetype (case op 
			       [("+") "Add"] 
			       [("-") "Sub"]
			       [("/") "Div"]
			       [("*") "Mult"]
			       [("%") "Mod"]
			       [("//") "FloorDiv"]
			       [else (error "Bad arith_expr/term op")])))]

    [(list (or 'and_test 'or_test) expr1 op expr2)
     (ast 'nodetype "BoolOp"
	  'op (ast 'nodetype (case op 
			       [("or") "Or"] 
			       [("and") "And"] 
			       [else (error "Bad boolean op")]))
	  'values (list (expr->python-ast expr1 expr-ctx)
			(expr->python-ast expr2 expr-ctx)))]

    #| Calls - see trailer->ast-list |#
    [(list 'power func (and (cons 'trailer _) (app trailer->ast-list arglist)))
     (ast 'nodetype "Call"
	  'args arglist
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '()
	  'func (expr->python-ast func "Load"))]

    [(list 'not_test "not" expr)
     (ast 'nodetype "UnaryOp"
	  'op (ast 'nodetype "Not")
	  'operand (expr->python-ast expr expr-ctx))]
    
    [(list 'factor "-" expr)
     (ast 'nodetype "UnaryOp"
	  'op (ast 'nodetype "USub")
	  'operand (expr->python-ast expr expr-ctx))]

    ; Note expr-ctx (this may be wrong)
    ; Cons here is from token construction in the lexer
    [(list 'atom (cons 'name name))
     (ast 'nodetype "Name"
	   'id name
	   'ctx (ast 'nodetype expr-ctx))]

    ; Cons here is from token construction in the lexer
    [(list 'atom (cons type val))
     (if (equal? expr-ctx "Store")
	 (error "Cannot store to a literal")
	 (cond [(member type '(integer float imaginary)) 
		(ast 'nodetype "Num"
		      'n val)]
	       [(member type '(string))
		(ast 'nodetype "Str"
		     's val)]
	       [else (error "Literal not handled yet")]))]

    #| Dict - Temporary single item form... |#
    [(list 'atom "{" (list 'dictorsetmaker key ":" value) "}")
     (ast 'nodetype "Dict"
	  'keys (list (expr->python-ast key expr-ctx))
	  'values (list (expr->python-ast value expr-ctx)))]
    
    ;; No tuples for now
    [(list 'atom "(" expr ")")
     (expr->python-ast expr expr-ctx)]

    [_ 
     (display "=== Unhandled expression ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled expression"))]))
