#lang racket

(require racket/match
         "python-lexer.rkt"
         "python-grammar.rkt")

(provide parse-python)

#| 

The AST expected by get-structured-python is a has of symbol -> (string | number | AST), as produced by Python's AST library and imported in parse-python.rkt. The main non-obvious aspect of it is the 'ctx attribute of each expression node, which is (probably) determined by the statement and expression productions. 

The AST generated by ragg is syntax-object, which is basically a map of the entire derivation of the program.

Example:
(syntax->datum (parse '(NAME NEWLINE)))
'(file_input
  (stmt
   (simple_stmt
    (small_stmt
     (expr_stmt
      (testlist (test (or_test (and_test (not_test (comparison (expr (xor_expr (and_expr (shift_expr (arith_expr (term (factor (power (atom NAME)))))))))))))))))
    NEWLINE)))

|#

;; Unless noted, unmatched cases are unhandled and matched cases are thought to be correct.
;; Some cases are very specific to covered set of python reference tests at the moment.

#|
Some pseudo-types used in function names to help make this legible...

(define (stmt? sexp)
  (any expression that can be derived starting with stmt))

(define (expr? sexp)
  (any expression that can be derived starting with testlist_star_expr (probably)))

trailer, comp-op, suite and others should match their car
|#


(define (parse-python port)
  (module->ast (syntax->datum (parse (get-python-lexer port)))))

(define ast hasheq)

(define (args-ast arg-name-list default-asts vararg kwarg)
  (ast 'args (map (lambda (n)
                    (ast 'nodetype "arg"
                         'annotation #\nul
                         'arg n))
                  arg-name-list)
       'defaults default-asts
       'nodetype "arguments"
       'vararg vararg
       'kwargannotation #\nul
       'kwarg kwarg
       'varargannotation #\nul
       'kw_defaults '()
       'kwonlyargs '()))

(define (module->ast py-ragg)
  (match py-ragg
    [(list 'file_input stmts ...)
     (ast 'nodetype "Module"
          'body (map stmt->ast stmts))]
    [_ (error "Only file_input is supported.")]))


;; Transform most of the non-expression grammar from ragg into the ast (hasheq symbol->various) format
(define (stmt->ast py-ragg)
  (match py-ragg
    [(list (or 'stmt 'flow_stmt 'small_stmt 'compound_stmt) stmt) 
     (stmt->ast stmt)]
    
    ;; sipmle_stmt TODO: Multiple statements, trailing semicolon
    [(list 'simple_stmt stmt NEWLINE) (stmt->ast stmt)]

    [(list 'yield_stmt expr)
     (ast 'nodetype "Expr"
          'value (expr->ast expr "Load"))]

    [(list 'continue_stmt "continue") 
     (ast 'nodetype "Continue")]
    
    [(list 'break_stmt "break")
     (ast 'nodetype "Break")]
    
    ;; TODO: Allow only assignments to those allowed by http://docs.python.org/3.2/reference/simple_stmts.html#assignment-statements
    ;; expr_stmt TODO: multiple targets, multiple values? (in expr->ast ?)
    [(list 'expr_stmt testlist "=" val)
     (ast 'nodetype "Assign"
          'targets (list (expr->ast testlist "Store"))
          'value (expr->ast val "Load"))]

    [(list 'expr_stmt testlist (list 'augassign op) val)
     (ast 'nodetype "AugAssign"
          'op (ast 'nodetype (case op 
                               [("+=") "Add"]
                               [("-=") "Sub"]
                               [("*=") "Mult"]
                               [("/=") "Div"]
                               [("%=") "Mod"]
                               [("&=") "BitAnd"]
                               [("|=") "BitOr"]
                               [("^=") "BitXor"]
                               [(">>=") "RShift"]
                               [("**=") "Pow"]
                               [("//=") "FloorDiv"]
                               [else (error "Unrecognized augassign op")]))
          'target (expr->ast testlist "Store")
          'value (expr->ast val "Load"))]

    [(list 'expr_stmt val)
     (ast 'nodetype "Expr"
          'value (expr->ast val "Load"))]

    [(list 'return_stmt "return" val)
     (ast 'nodetype "Return"
          'value (expr->ast val "Load"))]

    [(list 'return_stmt "return")
     (ast 'nodetype "Return"
          'value #\nul)]

    [(list 'del_stmt "del" expr)
     (ast 'nodetype "Delete"
          'targets (exprlist->ast-list expr "Del"))]

    ;; raise_stmt TODO: from clause
    [(list 'raise_stmt "raise" exc)
     (ast 'nodetype "Raise"
          'exc (expr->ast exc "Load")
          'cause #\nul)]

    [(list 'raise_stmt "raise")
     (ast 'nodetype "Raise"
          'exc #\nul
          'cause #\nul)]

    [(list 'pass_stmt "pass")
     (ast 'nodetype "Pass")]

    ;; assert_stmt TODO: msg, multiple
    [(list 'assert_stmt "assert" expr)
     (ast 'nodetype "Assert"
          'test (expr->ast expr "Load")
          'msg #\nul)]

    [(list 'global_stmt "global" rest ...)
     (ast 'nodetype "Global"
          'names (map cdr (every-other rest)))]

    [(list 'nonlocal_stmt "nonlocal" rest ...)
     (ast 'nodetype "Nonlocal"
          'names (map cdr (every-other rest)))]

    [(list 'with_stmt "with" clauses ... ":" with-suite)
     (car
      (foldl 
       (lambda (with_clause inner-ast-list)
         (match with_clause
           [`(with_item ,elt-expr)
            (list (ast 'nodetype "With"
                       'body inner-ast-list
                       'optional_vars #\nul
                       'context_expr (expr->ast elt-expr "Load")))]
           [`(with_item ,elt-expr "as" ,var-expr)
            (list (ast 'nodetype "With"
                       'body inner-ast-list
                       'optional_vars (expr->ast var-expr "Store")
                       'context_expr (expr->ast elt-expr "Load")))]
           [_ (error "Bad with clause")]))
       (suite->ast-list with-suite)
       (reverse (every-other clauses))))]

    ;; if_stmt TODO: multiple elif and opt. else
    [(list 'if_stmt "if" test ":" suite)
     (ast 'nodetype "If"
          'orelse '()
          'test (expr->ast test "Load")
          'body (suite->ast-list suite))]
    
    [(list 'if_stmt "if" test ":" suite1 "else" ":" suite2)
     (ast 'nodetype "If"
          'test (expr->ast test "Load")
          'body (suite->ast-list suite1)
          'orelse (suite->ast-list suite2))]

    ;; import_stmt TODO: Everything
    [`(import_stmt (import_name "import" (dotted_as_names (dotted_as_name (dotted_name (name . ,name))))))
     (ast 'nodetype "Import"
          'names (list (ast 'nodetype "alias"
                            'name name
                            'asname #\nul)))]

    [`(import_stmt (import_name "import" (dotted_as_names (dotted_as_name (dotted_name (name . ,module-name)) "as" (name . ,as-name)))))
     (ast 'nodetype "Import"
          'names (list (ast 'nodetype "alias"
                            'name module-name
                            'asname as-name)))]

    [`(import_stmt (import_from "from" (dotted_name (name . ,module-name)) "import" "*"))
     (ast 'nodetype "ImportFrom"
          'level 0
          'module module-name
          'names (list (ast 'nodetype "alias"
                            'name "*"
                            'asname #\nul)))]

    ;; TODO: Less bad
    [(list 'try_stmt "try" ":" try-suite rest ...)
     (local ((define (more-clauses lst handler-ast-list orelse-ast-list finalbody-ast-list)
               (if (null? lst)
                   (let ((try-except-ast 
                          (ast 'nodetype "TryExcept"
                               'body (suite->ast-list try-suite)
                               'orelse orelse-ast-list
                               'handlers (reverse handler-ast-list))))
                     (if (null? finalbody-ast-list) 
                         try-except-ast
                         (ast 'nodetype "TryFinally"
                              'body (if (null? handler-ast-list)
                                        (suite->ast-list try-suite)
                                        (list try-except-ast))
                              'finalbody finalbody-ast-list)))
                   (match lst
                     [(list "finally" ":" finally-suite rest ...)
                      (more-clauses rest
                                    handler-ast-list
                                    orelse-ast-list
                                    (suite->ast-list finally-suite))]
                     [(list "else" ":" else-suite rest ...)
                      (more-clauses rest
                                    handler-ast-list
                                    (suite->ast-list else-suite)
                                    finalbody-ast-list)]
                     [(list (list 'except_clause "except" test "as" (cons 'name e-name)) ":" handler-suite rest ...)
                      (more-clauses rest
                                    (cons 
                                     (ast 'nodetype "ExceptHandler"
                                          'body (suite->ast-list handler-suite) 
                                          'name e-name
                                          'type (expr->ast test "Load"))
                                     handler-ast-list)
                                    orelse-ast-list
                                    finalbody-ast-list)]
                     [(list (list 'except_clause "except" test) ":" handler-suite rest ...)
                      (more-clauses rest
                                    (cons 
                                     (ast 'nodetype "ExceptHandler"
                                          'body (suite->ast-list handler-suite) 
                                          'name #\nul
                                          'type (expr->ast test "Load"))
                                     handler-ast-list)
                                    orelse-ast-list
                                    finalbody-ast-list)]
                     [(list (list 'except_clause "except") ":" handler-suite rest ...)
                      (more-clauses rest
                                    (cons 
                                     (ast 'nodetype "ExceptHandler"
                                          'body (suite->ast-list handler-suite) 
                                          'name #\nul
                                          'type #\nul)
                                     handler-ast-list)
                                    orelse-ast-list
                                    finalbody-ast-list)]))))
            (more-clauses rest '() '() '()))]
    
    [(list 'try_stmt "try" ":" try-suite "finally" ":" finally-suite)
     (ast 'nodetype "TryFinally"
          'body (suite->ast-list try-suite)
          'finalbody (suite->ast-list finally-suite))]

    [(list 'while_stmt "while" test-expr ":" body-suite)
     (ast 'nodetype "While"
          'test (expr->ast test-expr "Load")
          'orelse '()
          'body (suite->ast-list body-suite))]

    [(list 'while_stmt "while" test-expr ":" body-suite "else" ":" else-suite)
     (ast 'nodetype "While"
          'test (expr->ast test-expr "Load")
          'orelse (suite->ast-list else-suite)
          'body (suite->ast-list body-suite))]

    [(list 'for_stmt "for" bound-list "in" expr-list ":" body-suite "else" ":" else-suite)
     (ast 'nodetype "For"
          'iter (expr->ast expr-list "Load")
          'target (exprlist->ast bound-list "Store")
          'body (suite->ast-list body-suite)
          'orelse (suite->ast-list else-suite))]

    [(list 'for_stmt "for" bound-list "in" expr-list ":" body-suite)
     (ast 'nodetype "For"
          'iter (expr->ast expr-list "Load")
          'target (exprlist->ast bound-list "Store")
          'body (suite->ast-list body-suite)
          'orelse '())]

    ;; funcdef TODO: Almost everything 
    [`(funcdef "def" 
               (name . ,name) 
               (parameters "(" (typedargslist ,args ...) ")") ":" ,suite)
     (ast 'nodetype "FunctionDef"
          'body (suite->ast-list suite)
          'args (build-formals args)
          'name name
          'returns #\nul
          'decorator_list '())]

    [`(funcdef "def" 
               (name . ,name) 
               (parameters "(" ")") ":" ,suite)
     (ast 'nodetype "FunctionDef"
          'body (suite->ast-list suite)
          'args (args-ast '() '() #\nul #\nul)
          'name name
          'returns #\nul
          'decorator_list '())]

    [`(classdef "class" (name . ,name) ":" ,suite)
     (ast 'nodetype "ClassDef"
          'body (suite->ast-list suite)
          'bases '()
          'name name
          'decorator_list '()
          'kwargs #\nul
          'starargs #\nul
          'keywords '())]

    [`(classdef "class" (name . ,name) "(" (arglist ,supertypes ...) ")" ":" ,suite)
     (ast 'nodetype "ClassDef"
          'body (suite->ast-list suite)
          'bases (arglist->ast-list supertypes '())
          'name name
          'decorator_list '()
          'kwargs #\nul
          'starargs #\nul
          'keywords '())]

    [_ 
     (display "=== Unhandled grammar ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled grammar"))]))

;; Destructure ragg python expressions to python ast with ctx value appropriate to the statement, expression, and position.
;; I'm assuming for now that this will handle testlist *and* test, in all cases.
;; I believe the expr-ctx passed on will inherently be "Load" in almost all cases, 
;; but I'm passing expr-ctx forward until I'm sure.
(define (expr->ast py-ragg expr-ctx)
  (match py-ragg

    #| Expression fallthroughs... |#
    [(list (or 'test_nocond 'argument 'testlist_comp 'testlist_star_expr 'testlist 'test 'or_test 'and_test 'not_test 'comparison 'expr 'xor_expr 'and_expr 'shift_expr 'arith_expr 'term 'factor 'power) expr)
     (expr->ast expr expr-ctx)]

    ;; Single item handled above. All others are tuples.
    ;; Unhandled star_expr will be caught downwind.
    [(list (or 'testlist_star_expr 'testlist) elements ...)
     (ast 'nodetype "Tuple"
          'ctx (ast 'nodetype expr-ctx)
          'elts (map (lambda (e) (expr->ast e expr-ctx)) (every-other elements)))]

    [(list 'test t-expr "if" cond-expr "else" f-expr)
     (ast 'nodetype "IfExp"
          'test (expr->ast cond-expr "Load")
          'body (expr->ast t-expr "Load")
          'orelse (expr->ast f-expr "Load"))]

    [(list (or 'lambdef 'lambdef_nocond) "lambda" (list 'varargslist args ...) ":" expr)
     (ast 'nodetype "Lambda"
          'args (build-formals args)
          'body (expr->ast expr "Load"))]

    [(list (or 'lambdef 'lambdef_nocond) "lambda" ":" expr)
     (ast 'nodetype "Lambda"
          'args (args-ast '() '() #\nul #\nul)
          'body (expr->ast expr "Load"))]

    [(list 'yield_expr "yield" expr)
     (ast 'nodetype "Yield"
          'value (expr->ast expr "Load"))]

    [(list 'yield_expr "yield")
     (ast 'nodetype "Yield"
          'value #\nul)]
    
    ;; Single item is caught above.
    [(list 'comparison expr1 rest ...)
     (let ((ops (every-other rest))
           (exprs (every-other (cdr rest))))
       (ast 'nodetype "Compare"
            'left (expr->ast expr1 expr-ctx)
            'ops (map comp-op->ast ops)
            'comparators (map (lambda (e) (expr->ast e expr-ctx)) exprs)))]

    [(list (and lhs (or 'term 'arith_expr 'expr 'xor_expr 'and_expr 'shift_expr)) 
           expr1 rest ...)
     (let ((ops (every-other rest))
           (exprs (if (null? rest) '() (every-other (cdr rest)))))
       (foldl (lambda (op right-expr left-ast)
                (ast 'nodetype "BinOp"
                     'left left-ast
                     'right (expr->ast right-expr expr-ctx)
                     'op (ast 'nodetype (case op 
                                          [("+") "Add"] 
                                          [("-") "Sub"]
                                          [("/") "Div"]
                                          [("*") "Mult"]
                                          [("%") "Mod"]
                                          [("//") "FloorDiv"]
                                          [("|") "BitOr"]
                                          [("^") "BitXor"]
                                          [("&") "BitAnd"]
                                          [("<<") "LShift"]
                                          [(">>") "RShift"]
                                          [else (error "Bad arith/term op")]))))
              (expr->ast expr1 expr-ctx)
              ops
              exprs))]

    ;; Single item right hand sides should be caught in the fallthrough clause above.
    [(list (or 'and_test 'or_test) rest ...)
     (let ((exprs (every-other rest)))
       (ast 'nodetype "BoolOp"
            'op (ast 'nodetype (case (second rest)
                                 [("or") "Or"] 
                                 [("and") "And"] 
                                 [else (error "Bad boolean op")]))
            'values (map (lambda (e) (expr->ast e expr-ctx)) exprs)))]

    ;; TODO: Exponentiation in conjuction
    ;; Set expr-ctx as ctx on last of trailers... Pass "Load" to interiors
    ;; Single fall-through expression is at the top with the rest.
    [(and (list 'power val trailers ... last-trailer)
          (not (list _ ... "**" _)))
     (wrap-with-trailer 
      last-trailer 
      expr-ctx
      (foldl 
       (lambda (trailer left-ast)
         (wrap-with-trailer trailer "Load" left-ast))
       (expr->ast val "Load")
       trailers))]

    [(list 'not_test "not" expr)
     (ast 'nodetype "UnaryOp"
          'op (ast 'nodetype "Not")
          'operand (expr->ast expr expr-ctx))]
    
    [(list 'factor "-" expr)
     (ast 'nodetype "UnaryOp"
          'op (ast 'nodetype "USub")
          'operand (expr->ast expr expr-ctx))]

    ;; Note expr-ctx (this may be wrong)
    ;; Cons here is from token construction in the lexer
    [(list 'atom (cons 'name name))
     (ast 'nodetype "Name"
          'id name
          'ctx (ast 'nodetype expr-ctx))]

    ;; Cons here is from token construction in the lexer
    [(list 'atom (cons type val))
     (if (equal? expr-ctx "Store")
         (error "Cannot store to a literal")
         (cond [(member type '(integer float imaginary)) 
                (ast 'nodetype "Num"
                     'n val)]
               [(member type '(string))
                (ast 'nodetype "Str"
                     's val)]
               [else (error "Literal not handled yet")]))]

    [(list 'atom "{" "}")
     (ast 'nodetype "Dict"
          'values '()
          'keys '())]

    [(list 'atom "{" (list-rest 'dictorsetmaker ... (and items (list _ ":" _ ...))) "}")
     (local ((define (more-items items key-exprs value-exprs)
               (match items
                 [`() 
                  (ast 'nodetype "Dict"
                       'keys (map expr->value-ast (reverse key-exprs))
                       'values (map expr->value-ast (reverse value-exprs)))]
                 [`("," ,more ...)
                  (more-items more key-exprs value-exprs)]
                 [`(,key-expr ":" ,value-expr ,more ...)
                  (more-items more (cons key-expr key-exprs) (cons value-expr value-exprs))])))
            (more-items items '() '()))]

    [(list 'atom "[" "]")
     (ast 'nodetype "List"
          'elts '()
          'ctx (ast 'nodetype "Load"))]

    [(list 'atom "[" 
           (and (or (list 'testlist_comp _)
                    (list 'testlist_comp _ "," _ ...))
                (list 'testlist_comp exprs ...)) "]")
     (ast 'nodetype "List"
          'ctx (ast 'nodetype "Load")
          'elts (arglist->ast-list exprs '()))]
    
    [(list 'atom "[" (list 'testlist_comp elt-expr (and comp
                                                        (list 'comp_for _ ...))) "]")
     (build-comprehension elt-expr comp "ListComp")]

    ;; Neither of these should probably be here...
    [(list (or 'testlist_comp 'argument) elt-expr (and comp
                                                       (list 'comp_for _ ...)))
     (build-comprehension elt-expr comp "GeneratorExp")]

    ;; This makes the "type" expr very shaky...
    [(list 'testlist_comp expr1 "," exprs ...)
     (ast 'nodetype "Tuple"
          'ctx (ast 'nodetype expr-ctx)
          'elts (map (lambda (e) (expr->ast e expr-ctx)) (cons expr1 (every-other exprs))))]

    [(list 'atom "(" expr ")")
     (expr->ast expr expr-ctx)]

    [(list 'atom "(" ")")
     (ast 'nodetype "Tuple"
          'ctx (ast 'nodetype expr-ctx)
          'elts '())]

    [_ 
     (display "=== Unhandled expression ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled expression"))]))

(define (comp-op->ast comp-op)
  (ast 'nodetype
       (match (cdr comp-op)
         [`("<") "Lt"]
         [`(">") "Gt"]
         [`("==") "Eq"]
         [`(">=") "GtE"]
         [`("<=") "LtE"]
         [`("!=") "NotEq"]
         [`("in") "In"]
         [`("not" "in") "NotIn"]
         [`("<>") (error "<> operator is not supported.")]
         [`("is") "Is"]
         [`("is" "not") "IsNot"])))

(define (suite->ast-list suite)
  (match suite
    [(list 'suite stmt) 
     (list (stmt->ast stmt))]
    [(list 'suite "NEWLINE" "INDENT" stmts ... "DEDENT")
     (map stmt->ast stmts)]))

;; string * trailer * ast -> ast
;; Only handles function calls with positional args
;; Assume for now that expr-ctx will always be valid.
(define (wrap-with-trailer trailer expr-ctx left-ast)
  (local ((define (attr-ast attr)
            (ast 'nodetype "Attribute"
                 'ctx (ast 'nodetype expr-ctx)
                 'attr attr
                 'value left-ast))
          (define (subscript-slice-ast lower upper step)
            (ast 'nodetype "Subscript"
                 'value left-ast
                 'ctx (ast 'nodetype expr-ctx)
                 'slice (ast 'nodetype "Slice"
                             'lower lower
                             'upper upper
                             'step step)))
          (define (subscript-index-ast index)
            (ast 'nodetype "Subscript"
                 'ctx (ast 'nodetype expr-ctx)
                 'value left-ast
                 'slice (ast 'nodetype "Index"
                             'value index))))
         (match trailer
           [`(trailer "(" ")") (build-call '() left-ast)]
           ;; arglist TODO... comp_for?
           [`(trailer "(" (arglist ,args ...) ")") (build-call args left-ast)]
           [`(trailer "." (name . ,name)) (attr-ast name)]
           ;; subscriptlist TODO... "...", multiple indexes, multiple indexes w/slices
           [`(trailer "[" (subscriptlist (subscript ,index)) "]") 
            (subscript-index-ast (expr->ast index "Load"))]
           
           [`(trailer "[" (subscriptlist (subscript ":" (sliceop ":"))) "]")
            (subscript-slice-ast #\nul #\nul #\nul)]
           [`(trailer "[" (subscriptlist (subscript ,start ":" (sliceop ":"))) "]")
            (subscript-slice-ast (expr->ast start "Load") #\nul #\nul)]
           [`(trailer "[" (subscriptlist (subscript ":" (sliceop ":" ,step))) "]" )
            (subscript-slice-ast #\nul #\nul (expr->ast step "Load"))]
           [`(trailer "[" (subscriptlist (subscript ,lower ":" (sliceop ":" ,step))) "]")
            (subscript-slice-ast (expr->ast lower "Load") #\nul (expr->ast step "Load"))]
           [`(trailer "[" (subscriptlist (subscript ,lower ":" ,upper (sliceop ":"))) "]")
            (subscript-slice-ast (expr->ast lower "Load") (expr->ast upper "Load") #\nul)] 
           [`(trailer "[" (subscriptlist (subscript ,lower ":" ,upper (sliceop ":" ,step))) "]")
            (subscript-slice-ast (expr->ast lower "Load") (expr->ast upper "Load") (expr->ast step "Load"))]
           [_ 
            (display "=== Unhandled trailer ===\n")
            (pretty-write trailer)
            (error "Unsupported trailer (arglist) shape")])))

(define (every-other lst)
  (cond [(null? lst) '()]
        [(null? (cdr lst)) (list (car lst))]
        [else (cons (car lst) (every-other (cddr lst)))]))

;; The single comprehension case is handled by fall-through in expr->ast
(define (build-call args func-ast)
  (local ((define (more-args args pos-args key-args stararg kwarg)
            (match args
              [`() 
               (ast 'nodetype "Call"
                    'args (reverse pos-args)
                    'kwargs kwarg
                    'starargs stararg
                    'keywords (reverse key-args)
                    'func func-ast)]
              [`("," ,more ...)
               (more-args more pos-args key-args stararg kwarg)]
              [`("*" ,vararg-expr ,more ...)
               (more-args more pos-args key-args (expr->value-ast vararg-expr) kwarg)]
              [`("**" ,kwarg-expr ,more ...)
               (more-args more pos-args key-args stararg (expr->value-ast kwarg-expr))]
              [`((argument ,key "=" ,val) ,more ...)
               (more-args more pos-args 
                          (cons (ast 'nodetype "keyword"
                                          ;; This is backwards but works.
                                          ;; See the note in the grammar.
                                     'arg (hash-ref (expr->value-ast key) 'id)
                                     'value (expr->value-ast val)) key-args)
                          stararg kwarg)]
              ;; bare generators grumble grumble
              [`((argument ,expr ,comp_for) ,more ...)
               (more-args more 
                          (cons (build-comprehension expr comp_for "GeneratorExp") pos-args) 
                          key-args stararg kwarg)]
              [`((argument ,expr) ,more ...)
               (more-args more (cons (expr->value-ast expr) pos-args) key-args stararg kwarg)]
              [_ 
               (display args) (newline)
               (error "Error parsing args")])))
         (more-args args '() '() #\nul #\nul)))

;; Turns a comma-separated list of exprs (expr first) to an ast list of exprs
(define (arglist->ast-list arg-lst acc)
  (match arg-lst
    [(list) (reverse acc)]
    [(list arg) (reverse (cons (expr->ast arg "Load") acc))]
    [(list arg "," rest ...) (arglist->ast-list rest (cons (expr->ast arg "Load") acc))]))

(define (exprlist->ast lst expr-ctx)
  (match lst
    [(list 'exprlist expr) (expr->ast expr expr-ctx)]
    [(list 'exprlist rest ...)
     (ast 'nodetype "Tuple"
          'ctx (ast 'nodetype expr-ctx)
          'elts (map (lambda (e) (expr->ast e expr-ctx)) (every-other rest)))]))

(define (exprlist->ast-list lst expr-ctx)
  (map (lambda (e) (expr->ast e expr-ctx)) (every-other (cdr lst))))

;; Currently covers both typedargslist and varargslist
(define (build-formals args)
  (local ((define (more-args args positional-arg-names default-asts vararg kwarg)
            (match args
              [`() (args-ast (reverse positional-arg-names) (reverse default-asts) vararg kwarg)]
              [`("," ,more ...)
               (more-args more positional-arg-names default-asts vararg kwarg)]
              [`("*" (,(or 'tfpdef 'vfpdef) (name . ,name)) ,more ...)
               (more-args more positional-arg-names default-asts name kwarg)]
              [`("**" (,(or 'tfpdef 'vfpdef) (name . ,name)) ,more ...)
               (more-args more positional-arg-names default-asts vararg name)]
              [`((,(or 'tfpdef 'vfpdef) (name . ,arg-name)) "=" ,default-expr ,more ...)
               (more-args more
                          (cons arg-name positional-arg-names)
                          (cons (expr->ast default-expr "Load") default-asts)
                          vararg kwarg)]
              ;; Match order is significant here
              [`((,(or 'tfpdef 'vfpdef) (name . ,arg-name)) ,more ...)
               (more-args more (cons arg-name positional-arg-names) default-asts vararg kwarg)]
              [_ (display "=== Unhandled formal argument ===") (newline)
                 (pretty-write args)
                 (error "Unhandled formal argument")])))
         (more-args args '() '() #\nul #\nul)))

(define (expr->value-ast expr)
  (expr->ast expr "Load"))

(define (build-comprehension elt-expr comp comp-nodetype)
  (local ((define (generator-ast target-expr iter-expr if-exprs)
            (ast 'nodetype "comprehension"
                 'target (exprlist->ast target-expr "Store")
                 'iter (expr->ast iter-expr "Load")
                 'ifs (map expr->value-ast if-exprs)))
          (define (more-clauses comp generators cur-target cur-iter current-ifs)
            (match comp
              [`() 
               (let ((gen (generator-ast cur-target cur-iter (reverse current-ifs))))
                     (ast 'nodetype comp-nodetype 
                          'elt (expr->ast elt-expr "Load")
                          'generators (reverse (cons gen generators))))]
              [`((comp_iter (comp_for "for" ,target-expr "in" ,iter-expr ,more ...)))
               (let ((gen (generator-ast cur-target cur-iter (reverse current-ifs))))
                 (more-clauses more (cons gen generators) target-expr iter-expr '()))]
              [`((comp_iter (comp_if "if" ,if-expr ,more ...)))
               (more-clauses more generators cur-target cur-iter (cons if-expr current-ifs))]
              [_
               (display "=== Unhandled comprehension clause ===") (newline)
               (pretty-write comp)
               (error "Unhandled comprehension clause")])))
         (match comp 
           [`(comp_for "for" ,target-expr "in" ,iter-expr ,more ...)
                      (more-clauses more '() target-expr iter-expr '())]
           [_ (error "Argument to build-comprehension must be a comp_for")])))

