#lang racket

(require racket/match
	 "python-lexer.rkt"
	 "python-grammar.rkt")

(provide parse-python)

#| 

The AST expected by get-structured-python is a has of symbol -> (string | number | AST), as produced by Python's AST library and imported in parse-python.rkt. The main non-obvious aspect of it is the 'ctx attribute of each expression node, which is (probably) determined by the statement and expression productions. 

The AST generated by ragg is syntax-object, which is basically a map of the entire derivation of the program.

Example:
(syntax->datum (parse '(NAME NEWLINE)))
'(file_input
  (stmt
   (simple_stmt
    (small_stmt
     (expr_stmt
      (testlist (test (or_test (and_test (not_test (comparison (expr (xor_expr (and_expr (shift_expr (arith_expr (term (factor (power (atom NAME)))))))))))))))))
    NEWLINE)))

|#

;; Unless noted, unmatched cases are unhandled and matched cases are thought to be correct.
;; Some cases are very specific to covered set of python reference tests at the moment.

(define (parse-python port)
  (module->ast (syntax->datum (parse (get-python-lexer port)))))

(define ast hasheq)

(define (args arg-list)
  (ast 'args arg-list
       'defaults '()
       'nodetype "arguments"
       'vararg #\nul
       'kwargannotation #\nul
       'kwarg #\nul
       'varargannotation #\nul
       'kw_defaults '()
       'kwonlyargs '()))


(define (module->ast py-ragg)
  (match py-ragg
    [(list 'file_input stmts ...)
     (ast 'nodetype "Module"
	   'body (map stmt->ast stmts))]
    [_ (error "Only file_input is supported.")]))


;; Transform most of the non-expression grammar from ragg into the ast (hasheq symbol->various) format
(define (stmt->ast py-ragg)
  (match py-ragg
    [(list (or 'stmt 'flow_stmt 'small_stmt 'compound_stmt) stmt) 
     (stmt->ast stmt)]

    [(list 'simple_stmt stmt NEWLINE) (stmt->ast stmt)] ; Todo: simple-stmt-multi.py
    
    ; TODO: Allow only assignments to those allowed by http://docs.python.org/3.2/reference/simple_stmts.html#assignment-statements
    ;; expr_stmt TODO: multiple targets, multiple values? (in expr->ast ?)
    [(list 'expr_stmt testlist "=" val)
     (ast 'nodetype "Assign"
	   'targets (list (expr->ast testlist "Store"))
	   'value (expr->ast val "Load"))]

    [(list 'expr_stmt testlist (list 'augassign op) val)
     (ast 'nodetype "AugAssign"
	  'op (ast 'nodetype (case op 
			       [("+=") "Add"]
			       [("-=") "Sub"]
			       [("*=") "Mult"]
			       [("/=") "Div"]
			       [("%=") "Mod"]
			       [("&=") "BitAnd"]
			       [("|=") "BitOr"]
			       [("^=") "BitXor"]
			       [(">>=") "RShift"]
			       [("**=") "Pow"]
			       [("//=") "FloorDiv"]
			       [else (error "Unrecognized augassign op")]))
	  'target (expr->ast testlist "Store")
	  'value (expr->ast val "Load"))]

    [(list 'expr_stmt val)
     (ast 'nodetype "Expr"
	  'value (expr->ast val "Load"))]

    [(list 'return_stmt "return" val)
     (ast 'nodetype "Return"
	  'value (expr->ast val "Load"))]

    ;; raise_stmt TODO: from clause
    [(list 'raise_stmt "raise" exc)
     (ast 'nodetype "Raise"
	  'exc (expr->ast exc "Load")
	  'cause #\nul)]

    [(list 'pass_stmt "pass")
     (ast 'nodetype "Pass")]
    
    ;; assert_stmt TODO: msg
    [(list 'assert_stmt "assert" expr)
     (ast 'nodetype "Assert"
	  'test (expr->ast expr "Load")
	  'msg #\nul)]

    ;; global_stmt TODO: multiple names
    [(list 'global_stmt "global" (cons 'name name))
     (ast 'nodetype "Global"
	  'names (list name))]

    ;; if_stmt TODO: multiple elif and opt. else
    [(list 'if_stmt "if" test ":" suite)
     (ast 'nodetype "If"
	  'orelse '()
	  'test (expr->ast test "Load")
	  'body (suite->ast-list suite))]
    
    [(list 'if_stmt "if" test ":" suite1 "else" ":" suite2)
     (ast 'nodetype "If"
	  'test (expr->ast test "Load")
	  'body (suite->ast-list suite1)
	  'orelse (suite->ast-list suite2))]
    
    ;; try_stmt TODO: All, this is a very special case
    [(list 'try_stmt "try" ":" try-suite 
	   (list 'except_clause "except" except-expr) ":" except-suite
	   "else" ":" else-suite)
     (ast 'nodetype "TryExcept"
	  'body (suite->ast-list try-suite)
	  'orelse (suite->ast-list else-suite)
	  'handlers (list (ast 'nodetype "ExceptHandler"
			       'name #\nul
			       'body (suite->ast-list except-suite)
			       'type (expr->ast except-expr "Load"))))]
     
    ;; funcdef TODO: Almost everything
    [`(funcdef "def" (name . ,name) (parameters "(" ")") ":" ,suite)
     (ast 'nodetype "FunctionDef"
	  'body (suite->ast-list suite)
	  'args (args '())
	  'name name
	  'returns #\nul
	  'decorator_list '())]

    ;; classdef TODO: Almost everything
    [`(classdef "class" (name . ,name) ":" ,suite)
     (ast 'nodetype "ClassDef"
	  'body (suite->ast-list suite)
	  'bases '()
	  'name name
	  'decorator_list '()
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '())]

    [_ 
     (display "=== Unhandled grammar ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled grammar"))]))

;; Destructure ragg python expressions to python ast with ctx value appropriate to the statement, expression, and position.
;; I believe the expr-ctx passed on will inherently be "Load" in almost all cases, 
;; but I'm passing expr-ctx forward until I'm sure
(define (expr->ast py-ragg expr-ctx)
  (match py-ragg

    #| Expression fallthroughs... |#
    [(list (or 'argument 'testlist_comp 'testlist 'test 'or_test 'and_test 'not_test 'comparison 'expr 'xor_expr 'and_expr 'shift_expr 'arith_expr 'term 'factor 'power) expr)
     (expr->ast expr expr-ctx)]
    
    ;; Single item is caught above.
    [(list 'comparison expr1 rest ...)
     (let ((ops (every-other rest))
	   (exprs (every-other (cdr rest))))
       (ast 'nodetype "Compare"
	    'left (expr->ast expr1 expr-ctx)
	    'ops (map comp-op->ast ops)
	    'comparators (map (lambda (e) (expr->ast e expr-ctx)) exprs)))]
#|    [(list 'comparison (and (not (cons 'comparison _)) expr1) comp-op (and (not (cons 'comparison _)) expr2))
     (ast 'nodetype "Compare"
	  'left (expr->ast expr1 expr-ctx)
	  'ops (list (comp-op->ast comp-op))
	  'comparators (list (expr->ast expr2 expr-ctx)))]|#

    [(list (and lhs (or 'term 'arith_expr 'expr 'xor_expr 'and_expr 'shift_expr)) 
	   expr1 rest ...)
     (let ((ops (every-other rest))
	   (exprs (if (null? rest) '() (every-other (cdr rest)))))
       (foldl (lambda (op right-expr left-ast)
		(ast 'nodetype "BinOp"
		     'left left-ast
		     'right (expr->ast right-expr expr-ctx)
		     'op (ast 'nodetype (case op 
					  [("+") "Add"] 
					  [("-") "Sub"]
					  [("/") "Div"]
					  [("*") "Mult"]
					  [("%") "Mod"]
					  [("//") "FloorDiv"]
					  [("|") "BitOr"]
					  [("^") "BitXor"]
					  [("&") "BitAnd"]
					  [("<<") "LShift"]
					  [(">>") "RShift"]
					  [else (error "Bad arith/term op")]))))
	      (expr->ast expr1 expr-ctx)
	      ops
	      exprs))]

    ;; TODO: Exponention in power, below (binds other way)

    ;; Single item right hand sides should be caught in the fallthrough clause above.
    [(list (or 'and_test 'or_test) rest ...)
     (let ((exprs (every-other rest)))
       (ast 'nodetype "BoolOp"
	    'op (ast 'nodetype (case (second rest)
			       [("or") "Or"] 
			       [("and") "And"] 
			       [else (error "Bad boolean op")]))
	    'values (map (lambda (e) (expr->ast e expr-ctx)) exprs)))]

    #| Calls - see trailer->ast-list |#
    ;; TODO: Multiple trailers in conjuction with exponentiation
    [(list 'power func (and (list 'trailer "(" _ ...) (app trailer->ast-list arglist)))
     (ast 'nodetype "Call"
	  'args arglist
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '()
	  'func (expr->ast func "Load"))]

    [(list 'not_test "not" expr)
     (ast 'nodetype "UnaryOp"
	  'op (ast 'nodetype "Not")
	  'operand (expr->ast expr expr-ctx))]
    
    [(list 'factor "-" expr)
     (ast 'nodetype "UnaryOp"
	  'op (ast 'nodetype "USub")
	  'operand (expr->ast expr expr-ctx))]

    ; Note expr-ctx (this may be wrong)
    ; Cons here is from token construction in the lexer
    [(list 'atom (cons 'name name))
     (ast 'nodetype "Name"
	   'id name
	   'ctx (ast 'nodetype expr-ctx))]

    ; Cons here is from token construction in the lexer
    [(list 'atom (cons type val))
     (if (equal? expr-ctx "Store")
	 (error "Cannot store to a literal")
	 (cond [(member type '(integer float imaginary)) 
		(ast 'nodetype "Num"
		      'n val)]
	       [(member type '(string))
		(ast 'nodetype "Str"
		     's val)]
	       [else (error "Literal not handled yet")]))]

    #| Dict - Temporary single item form... |#
    [(list 'atom "{" (list 'dictorsetmaker key ":" value) "}")
     (ast 'nodetype "Dict"
	  'keys (list (expr->ast key expr-ctx))
	  'values (list (expr->ast value expr-ctx)))]
    
    ;; No tuples for now
    [(list 'atom "(" expr ")")
     (expr->ast expr expr-ctx)]

    [_ 
     (display "=== Unhandled expression ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled expression"))]))

;; Takes two strings. If they are the same, return ast as if it is a one-word op.
;; Only changes the result for "is not".
(define (comp-op->ast comp-op)
  (ast 'nodetype
       (match (cdr comp-op)
	 [`("<") "Lt"]
	 [`(">") "Gt"]
	 [`("==") "Eq"]
	 [`(">=") "GtE"]
	 [`("<=") "LtE"]
	 [`("!=") "NotEq"]
	 [`("in") "In"]
	 [`("not" "in") "NotIn"]
	 [`("<>") (error "<> operator is not supported.")]
	 [`("is") "Is"]
	 [`("is" "not") "IsNot"])))

(define (suite->ast-list suite)
  (match suite
    [(list 'suite stmt) 
     (list (stmt->ast stmt))]
    [(list 'suite "NEWLINE" "INDENT" stmts ... "DEDENT")
     (map stmt->ast stmts)]))

;; trailer: line to list of args 
;; Currently positional args only
(define (trailer->ast-list trailer)
  (local ((define (more-args arg-lst acc)
	    (match arg-lst
	      [(list) (reverse acc)]
	      [(list arg) (reverse (cons (expr->ast arg "Load") acc))]
	      [(list arg "," rest ...) (more-args rest (cons (expr->ast arg "Load") acc))])))
	 (match trailer
	   [(list 'trailer "(" ")") '()]
	   [(list 'trailer "(" (list 'arglist rest ...) ")") (more-args rest '())]
	   [_ (error "Unsupported trailer (arglist) shape")])))

(define (every-other lst)
  (cond [(null? lst) '()]
	[(null? (cdr lst)) (list (car lst))]
	[else (cons (car lst) (every-other (cddr lst)))]))
