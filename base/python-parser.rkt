#lang racket

(require racket/match
	 "python-lexer.rkt"
	 "python-grammar.rkt")

(provide parse-python)

#| 

The AST expected by get-structured-python is a has of symbol -> (string | number | AST), as produced by Python's AST library and imported in parse-python.rkt. The main non-obvious aspect of it is the 'ctx attribute of each expression node, which is (probably) determined by the statement and expression productions. 

The AST generated by ragg is syntax-object, which is basically a map of the entire derivation of the program.

Example:
(syntax->datum (parse '(NAME NEWLINE)))
'(file_input
  (stmt
   (simple_stmt
    (small_stmt
     (expr_stmt
      (testlist (test (or_test (and_test (not_test (comparison (expr (xor_expr (and_expr (shift_expr (arith_expr (term (factor (power (atom NAME)))))))))))))))))
    NEWLINE)))

|#

;; Unless noted, unmatched cases are unhandled and matched cases are thought to be correct.
;; Some cases are very specific to covered set of python reference tests at the moment.

#|
Some pseudo-types used in function names to help make this legible...

(define (stmt? sexp)
  (any expression that can be derived starting with stmt))

(define (expr? sexp)
  (any expression that can be derived starting with testlist (probably)))

trailer, comp-op, suite and others should match their car.
|#


(define (parse-python port)
  (module->ast (syntax->datum (parse (get-python-lexer port)))))

(define ast hasheq)

(define (args-ast arg-name-list)
  (ast 'args (map (lambda (n)
		    (ast 'nodetype "arg"
			 'annotation #\nul
			 'arg n))
		  arg-name-list)
       'defaults '()
       'nodetype "arguments"
       'vararg #\nul
       'kwargannotation #\nul
       'kwarg #\nul
       'varargannotation #\nul
       'kw_defaults '()
       'kwonlyargs '()))

(define (module->ast py-ragg)
  (match py-ragg
    [(list 'file_input stmts ...)
     (ast 'nodetype "Module"
	   'body (map stmt->ast stmts))]
    [_ (error "Only file_input is supported.")]))


;; Transform most of the non-expression grammar from ragg into the ast (hasheq symbol->various) format
(define (stmt->ast py-ragg)
  (match py-ragg
    [(list (or 'stmt 'flow_stmt 'small_stmt 'compound_stmt) stmt) 
     (stmt->ast stmt)]

    [(list 'simple_stmt stmt NEWLINE) (stmt->ast stmt)] ; Todo: simple-stmt-multi.py
    
    ;; TODO: Allow only assignments to those allowed by http://docs.python.org/3.2/reference/simple_stmts.html#assignment-statements
    ;; expr_stmt TODO: multiple targets, multiple values? (in expr->ast ?)
    [(list 'expr_stmt testlist "=" val)
     (ast 'nodetype "Assign"
	   'targets (list (expr->ast testlist "Store"))
	   'value (expr->ast val "Load"))]

    [(list 'expr_stmt testlist (list 'augassign op) val)
     (ast 'nodetype "AugAssign"
	  'op (ast 'nodetype (case op 
			       [("+=") "Add"]
			       [("-=") "Sub"]
			       [("*=") "Mult"]
			       [("/=") "Div"]
			       [("%=") "Mod"]
			       [("&=") "BitAnd"]
			       [("|=") "BitOr"]
			       [("^=") "BitXor"]
			       [(">>=") "RShift"]
			       [("**=") "Pow"]
			       [("//=") "FloorDiv"]
			       [else (error "Unrecognized augassign op")]))
	  'target (expr->ast testlist "Store")
	  'value (expr->ast val "Load"))]

    [(list 'expr_stmt val)
     (ast 'nodetype "Expr"
	  'value (expr->ast val "Load"))]

    [(list 'return_stmt "return" val)
     (ast 'nodetype "Return"
	  'value (expr->ast val "Load"))]

    ;; raise_stmt TODO: from clause
    [(list 'raise_stmt "raise" exc)
     (ast 'nodetype "Raise"
	  'exc (expr->ast exc "Load")
	  'cause #\nul)]

    [(list 'pass_stmt "pass")
     (ast 'nodetype "Pass")]
    
    ;; assert_stmt TODO: msg
    [(list 'assert_stmt "assert" expr)
     (ast 'nodetype "Assert"
	  'test (expr->ast expr "Load")
	  'msg #\nul)]

    ;; global_stmt TODO: multiple names
    [(list 'global_stmt "global" (cons 'name name))
     (ast 'nodetype "Global"
	  'names (list name))]

    ;; if_stmt TODO: multiple elif and opt. else
    [(list 'if_stmt "if" test ":" suite)
     (ast 'nodetype "If"
	  'orelse '()
	  'test (expr->ast test "Load")
	  'body (suite->ast-list suite))]
    
    [(list 'if_stmt "if" test ":" suite1 "else" ":" suite2)
     (ast 'nodetype "If"
	  'test (expr->ast test "Load")
	  'body (suite->ast-list suite1)
	  'orelse (suite->ast-list suite2))]
    
    ;; try_stmt TODO: All, this is a very special case
    [(list 'try_stmt "try" ":" try-suite 
	   (list 'except_clause "except" except-expr) ":" except-suite
	   "else" ":" else-suite)
     (ast 'nodetype "TryExcept"
	  'body (suite->ast-list try-suite)
	  'orelse (suite->ast-list else-suite)
	  'handlers (list (ast 'nodetype "ExceptHandler"
			       'name #\nul
			       'body (suite->ast-list except-suite)
			       'type (expr->ast except-expr "Load"))))]
     
    ;; funcdef TODO: Almost everything 
    [`(funcdef "def" 
	       (name . ,name) 
	       (parameters "(" (varargslist (fpdef (name . ,args)) ...) ")") ":" ,suite)
     (ast 'nodetype "FunctionDef"
	  'body (suite->ast-list suite)
	  'args (args-ast args)
	  'name name
	  'returns #\nul
	  'decorator_list '())]

    [`(funcdef "def" 
	       (name . ,name) 
	       (parameters "(" ")") ":" ,suite)
     (ast 'nodetype "FunctionDef"
	  'body (suite->ast-list suite)
	  'args (args-ast '())
	  'name name
	  'returns #\nul
	  'decorator_list '())]

    ;; classdef, no supertypes
    [`(classdef "class" (name . ,name) ":" ,suite)
     (ast 'nodetype "ClassDef"
	  'body (suite->ast-list suite)
	  'bases '()
	  'name name
	  'decorator_list '()
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '())]

    [`(classdef "class" (name . ,name) "(" ,supertypes ... ")" ":" ,suite)
     (ast 'nodetype "ClassDef"
	  'body (suite->ast-list suite)
	  'bases (more-args supertypes '())
	  'name name
	  'decorator_list '()
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '())]

    [_ 
     (display "=== Unhandled grammar ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled grammar"))]))

;; Destructure ragg python expressions to python ast with ctx value appropriate to the statement, expression, and position.
;; I'm assuming for now that this will handle testlist *and* test, in all cases.
;; I believe the expr-ctx passed on will inherently be "Load" in almost all cases, 
;; but I'm passing expr-ctx forward until I'm sure.
(define (expr->ast py-ragg expr-ctx)
  (match py-ragg

    #| Expression fallthroughs... |#
    [(list (or 'argument 'testlist_comp 'testlist 'test 'or_test 'and_test 'not_test 'comparison 'expr 'xor_expr 'and_expr 'shift_expr 'arith_expr 'term 'factor 'power) expr)
     (expr->ast expr expr-ctx)]
    
    ;; Single item is caught above.
    [(list 'comparison expr1 rest ...)
     (let ((ops (every-other rest))
	   (exprs (every-other (cdr rest))))
       (ast 'nodetype "Compare"
	    'left (expr->ast expr1 expr-ctx)
	    'ops (map comp-op->ast ops)
	    'comparators (map (lambda (e) (expr->ast e expr-ctx)) exprs)))]

    [(list (and lhs (or 'term 'arith_expr 'expr 'xor_expr 'and_expr 'shift_expr)) 
	   expr1 rest ...)
     (let ((ops (every-other rest))
	   (exprs (if (null? rest) '() (every-other (cdr rest)))))
       (foldl (lambda (op right-expr left-ast)
		(ast 'nodetype "BinOp"
		     'left left-ast
		     'right (expr->ast right-expr expr-ctx)
		     'op (ast 'nodetype (case op 
					  [("+") "Add"] 
					  [("-") "Sub"]
					  [("/") "Div"]
					  [("*") "Mult"]
					  [("%") "Mod"]
					  [("//") "FloorDiv"]
					  [("|") "BitOr"]
					  [("^") "BitXor"]
					  [("&") "BitAnd"]
					  [("<<") "LShift"]
					  [(">>") "RShift"]
					  [else (error "Bad arith/term op")]))))
	      (expr->ast expr1 expr-ctx)
	      ops
	      exprs))]

    ;; Single item right hand sides should be caught in the fallthrough clause above.
    [(list (or 'and_test 'or_test) rest ...)
     (let ((exprs (every-other rest)))
       (ast 'nodetype "BoolOp"
	    'op (ast 'nodetype (case (second rest)
			       [("or") "Or"] 
			       [("and") "And"] 
			       [else (error "Bad boolean op")]))
	    'values (map (lambda (e) (expr->ast e expr-ctx)) exprs)))]

    ;; TODO: Exponentiation in conjuction
    ;; Set expr-ctx as ctx on last of trailers... Pass "Load" to interiors
    ;; Single fall-through expression is at the top with the rest.
    [(and (list 'power val trailers ... last-trailer)
	  (not (list _ ... "**" _)))
     (wrap-with-trailer 
      last-trailer 
      expr-ctx
      (foldl 
       (lambda (trailer left-ast)
	 (wrap-with-trailer trailer "Load" left-ast))
       (expr->ast val "Load")
       trailers))]

    [(list 'not_test "not" expr)
     (ast 'nodetype "UnaryOp"
	  'op (ast 'nodetype "Not")
	  'operand (expr->ast expr expr-ctx))]
    
    [(list 'factor "-" expr)
     (ast 'nodetype "UnaryOp"
	  'op (ast 'nodetype "USub")
	  'operand (expr->ast expr expr-ctx))]

    ;; Note expr-ctx (this may be wrong)
    ;; Cons here is from token construction in the lexer
    [(list 'atom (cons 'name name))
     (ast 'nodetype "Name"
	   'id name
	   'ctx (ast 'nodetype expr-ctx))]

    ;; Cons here is from token construction in the lexer
    [(list 'atom (cons type val))
     (if (equal? expr-ctx "Store")
	 (error "Cannot store to a literal")
	 (cond [(member type '(integer float imaginary)) 
		(ast 'nodetype "Num"
		      'n val)]
	       [(member type '(string))
		(ast 'nodetype "Str"
		     's val)]
	       [else (error "Literal not handled yet")]))]

    #| Dict - Temporary single item form... |#
    [(list 'atom "{" (list 'dictorsetmaker key ":" value) "}")
     (ast 'nodetype "Dict"
	  'keys (list (expr->ast key expr-ctx))
	  'values (list (expr->ast value expr-ctx)))]

    ;; temporary empty form
    [(list 'atom "[" "]")
     (ast 'nodetype "List"
	  'elts '()
	  'ctx (ast 'nodetype "Load"))]
    
    ;; Temporary single item form
    [(list 'atom "[" (list 'listmaker expr) "]")
     (ast 'nodetype "List"
	  'ctx (ast 'nodetype "Load")
	  'elts (list (expr->ast expr "Load")))]
    
    ;; No tuples for now
    [(list 'atom "(" expr ")")
     (expr->ast expr expr-ctx)]

    [_ 
     (display "=== Unhandled expression ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled expression"))]))

;; Takes two strings. If they are the same, return ast as if it is a one-word op.
;; Only changes the result for "is not".
(define (comp-op->ast comp-op)
  (ast 'nodetype
       (match (cdr comp-op)
	 [`("<") "Lt"]
	 [`(">") "Gt"]
	 [`("==") "Eq"]
	 [`(">=") "GtE"]
	 [`("<=") "LtE"]
	 [`("!=") "NotEq"]
	 [`("in") "In"]
	 [`("not" "in") "NotIn"]
	 [`("<>") (error "<> operator is not supported.")]
	 [`("is") "Is"]
	 [`("is" "not") "IsNot"])))

(define (suite->ast-list suite)
  (match suite
    [(list 'suite stmt) 
     (list (stmt->ast stmt))]
    [(list 'suite "NEWLINE" "INDENT" stmts ... "DEDENT")
     (map stmt->ast stmts)]))

;; string * trailer * ast -> ast
;; Only handles function calls with positional args
;; Assume for now that expr-ctx will always be valid.
(define (wrap-with-trailer trailer expr-ctx left-ast)
  (local ((define (call-ast arglist)
	    (ast 'nodetype "Call"
		 'args arglist
		 'kwargs #\nul
		 'starargs #\nul
		 'keywords '()
		 'func left-ast))
	  (define (attr-ast attr)
	    (ast 'nodetype "Attribute"
		 'ctx (ast 'nodetype expr-ctx)
		 'attr attr
		 'value left-ast))
	  (define (subscript-slice-ast lower upper step)
	    (ast 'nodetype "Subscript"
		 'value left-ast
		 'ctx (ast 'nodetype expr-ctx)
		 'slice (ast 'nodetype "Slice"
			     'lower lower
			     'upper upper
			     'step step)))
	  (define (subscript-index-ast index)
	    (ast 'nodetype "Subscript"
		 'ctx (ast 'nodetype expr-ctx)
		 'value left-ast
		 'slice (ast 'nodetype "Index"
			     'value index))))
	 (match trailer
	   [`(trailer "(" ")") (call-ast '())]
	   ;; arglist TODO... Almost everything
	   [`(trailer "(" (arglist ,rest ...) ")") (call-ast (more-args rest '()))]
	   [`(trailer "." (name . ,name)) (attr-ast name)]
	   ;; subscriptlist TODO... "...", multiple indexes, multiple indexes w/slices
	   [`(trailer "[" (subscriptlist (subscript ,index)) "]") 
	    (subscript-index-ast (expr->ast index "Load"))]
	   
	   [`(trailer "[" (subscriptlist (subscript ":" (sliceop ":"))) "]")
	    (subscript-slice-ast #\nul #\nul #\nul)]
	   [`(trailer "[" (subscriptlist (subscript ,start ":" (sliceop ":"))) "]")
	    (subscript-slice-ast (expr->ast start "Load") #\nul #\nul)]
	   [`(trailer "[" (subscriptlist (subscript ":" (sliceop ":" ,step))) "]" )
	    (subscript-slice-ast #\nul #\nul (expr->ast step "Load"))]
	   [`(trailer "[" (subscriptlist (subscript ,lower ":" (sliceop ":" ,step))) "]")
	    (subscript-slice-ast (expr->ast lower "Load") #\nul (expr->ast step "Load"))]
	   [`(trailer "[" (subscriptlist (subscript ,lower ":" ,upper (sliceop ":"))) "]")
	    (subscript-slice-ast (expr->ast lower "Load") (expr->ast upper "Load") #\nul)] 
	   [`(trailer "[" (subscriptlist (subscript ,lower ":" ,upper (sliceop ":" ,step))) "]")
	    (subscript-slice-ast (expr->ast lower "Load") (expr->ast upper "Load") (expr->ast step "Load"))]
	   [_ 
	    (display "=== Unhandled trailer ===\n")
	    (pretty-write trailer)
	    (error "Unsupported trailer (arglist) shape")])))

(define (every-other lst)
  (cond [(null? lst) '()]
	[(null? (cdr lst)) (list (car lst))]
	[else (cons (car lst) (every-other (cddr lst)))]))

(define (more-args arg-lst acc)
  (match arg-lst
    [(list) (reverse acc)]
    [(list arg) (reverse (cons (expr->ast arg "Load") acc))]
    [(list arg "," rest ...) (more-args rest (cons (expr->ast arg "Load") acc))]))
