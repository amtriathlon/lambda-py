#lang racket

(require racket/match
	 "python-lexer.rkt"
	 "python-grammar.rkt")

(provide parse-python)

#| 

The AST expected by get-structured-python is a symbol -> string | number | AST dictionary as produced by Python's AST library. The main non-trivial aspect of it is the 'ctx attribute of each expression node, which is (probably) determined by the statement and expression productions.

The AST generated by ragg is syntax-object, which is nested just like the grammar productions, e.g. really deeply.

Example:
(syntax->datum (parse '(NAME NEWLINE)))
'(file_input
  (stmt
   (simple_stmt
    (small_stmt
     (expr_stmt
      (testlist (test (or_test (and_test (not_test (comparison (expr (xor_expr (and_expr (shift_expr (arith_expr (term (factor (power (atom NAME)))))))))))))))))
    NEWLINE)))

|#

(define (parse-python port)
  (py-ragg->python-ast (syntax->datum (parse (get-python-lexer port)))))

(define ast hasheq)

(define (args arg-list)
  (ast 'args arg-list
       'defaults '()
       'nodetype "arguments"
       'vararg #\nul
       'kwargannotation #\nul
       'kwarg #\nul
       'varargannotation #\nul
       'kw_defaults '()
       'kwonlyargs '()))

(define (suite->ast-list suite)
  (match suite
    [(list 'suite stmt) 
     (list (py-ragg->python-ast stmt))]
    [(list 'suite "NEWLINE" "INDENT" stmts ... "DEDENT")
     (map py-ragg->python-ast stmts)]))

;; trailer: line to list of args 
;; Currently positional args only
(define (trailer->ast-list trailer)
  (local ((define (more-args arg-lst acc)
	    (match arg-lst
	      [(list) (reverse acc)]
	      [(list arg) (reverse (cons (py-ragg-expr->python-ast arg "Load") acc))]
	      [(list arg "," rest ...) (more-args (cons (py-ragg-expr->python-ast arg "Load") acc))])))
	 (match trailer
	   [(list 'trailer "(" ")") '()]
	   [(list 'trailer "(" (list 'arglist rest ...) ")") (more-args rest '())]
	   [_ (error "Unsupported trailer (arglist) shape")])))
	       

;; Transform most of the non-expression grammar from ragg into the ast (hasheq symbol->various) format
(define (py-ragg->python-ast py-ragg)
  (match py-ragg
    [(list 'file_input stmts ...)
     (ast 'nodetype "Module"
	   'body (map py-ragg->python-ast stmts))]
    
    [(list (or 'stmt 'flow_stmt 'small_stmt 'compound_stmt) stmt) 
     (py-ragg->python-ast stmt)]

    #| Simple version for python-reference/types... |#
    [(list 'if_stmt "if" test ":" suite)
     (ast 'nodetype "If"
	  'orelse '()
	  'test (py-ragg-expr->python-ast test "Load")
	  'body (suite->ast-list suite))]
    
    [(list 'simple_stmt stmt NEWLINE) (py-ragg->python-ast stmt)] ; Todo: simple-stmt-multi.py
    
    ; TODO: Allow only assignments to those allowed by http://docs.python.org/3.2/reference/simple_stmts.html#assignment-statements
    [(list 'expr_stmt testlist "=" val)
     (ast 'nodetype "Assign"
	   'targets (list (py-ragg-expr->python-ast testlist "Store"))
	   'value (py-ragg-expr->python-ast val "Load"))]

    [(list 'expr_stmt val)
     (ast 'nodetype "Expr"
	  'value (py-ragg-expr->python-ast val "Load"))]

    [(list 'raise_stmt "raise" exc)
     (ast 'nodetype "Raise"
	  'exc (py-ragg-expr->python-ast exc "Load")
	  'cause #\nul)]

    [(list 'pass_stmt "pass")
     (ast 'nodetype "Pass")]

    #| Temporary trivial fundef |#
    [`(funcdef "def" (name . ,name) (parameters "(" ")") ":" ,suite)
     (ast 'nodetype "FunctionDef"
	  'body (suite->ast-list suite)
	  'args (args '())
	  'name name
	  'returns #\nul
	  'decorator_list '())]

    #| Temporary trivial classdef |#
    [`(classdef "class" (name . ,name) ":" ,suite)
     (ast 'nodetype "ClassDef"
	  'body (suite->ast-list suite)
	  'bases '()
	  'name name
	  'decorator_list '()
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '())]

    [_ 
     (display "=== Unhandled grammar ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled grammar"))]))

; Destructure ragg python expressions to python-ast with ctx values
(define (py-ragg-expr->python-ast py-ragg expr-ctx)
  (match py-ragg

    #| Expression fallthroughs... |#
    [(list (or 'argument 'testlist 'test 'or_test 'and_test 'not_test 'comparison 'expr 'xor_expr 'and_expr 'shift_expr 'arith_expr 'term 'factor 'power) expr)
     (py-ragg-expr->python-ast expr expr-ctx)]

    #| Calls - see trailer->ast-list |#
    [(list 'power func (and (cons 'trailer _) (app trailer->ast-list arglist)))
     (ast 'nodetype "Call"
	  'args arglist
	  'kwargs #\nul
	  'starargs #\nul
	  'keywords '()
	  'func (py-ragg-expr->python-ast func "Load"))]

    [(list 'not_test "not" expr)
     (ast 'nodetype "UnaryOp"
	  'op (ast 'nodetype "Not")
	  'operand (py-ragg-expr->python-ast expr expr-ctx))]

    ; Note expr-ctx (this may be wrong)
    ; Cons here is from token construction in the lexer
    [(list 'atom (cons 'name name))
     (ast 'nodetype "Name"
	   'id name
	   'ctx (ast 'nodetype expr-ctx))]

    ; Cons here is from token construction in the lexer
    [(list 'atom (cons type val))
     (if (equal? expr-ctx "Store")
	 (error "Cannot store to a literal")
	 (cond [(member type '(integer float imaginary)) 
		(ast 'nodetype "Num"
		      'n val)]
	       [(member type '(string))
		(ast 'nodetype "Str"
		     's val)]
	       [else (error "Literal not handled yet")]))]

    #| Dict - Temporary single item form... |#
    [(list 'atom "{" (list 'dictorsetmaker key ":" value) "}")
     (ast 'nodetype "Dict"
	  'keys (list (py-ragg-expr->python-ast key expr-ctx))
	  'values (list (py-ragg-expr->python-ast value expr-ctx)))]

    [_ 
     (display "=== Unhandled expression ===\n")
     (pretty-write py-ragg)
     (error (string-append "Unhandled expression"))]))
